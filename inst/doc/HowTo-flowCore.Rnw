% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
%\VignetteIndexEntry{Basic Functions for Flow Cytometry Data}
%\VignetteDepends{flowCore}
%\VignetteKeywords{}
%\VignettePackage{flowCore}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{subfigure}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\bibliographystyle{plainnat}

\title{How to use flowCore package}
\author{N. Le Meur F. Hahne P. Haaland}

\begin{document}
\maketitle

\begin{abstract}
\noindent \textbf{Background} The recent application of modern automation technologies to staining and collecting flow cytometry (FCM) samples has led to many new challenges in data management and analysis. We limit our attention here to the associated problems in the analysis of the massive amounts of FCM data now being collected. From our viewpoint, see two related but substantially different problems arising. On the one hand, there is the problem of adapting existing software to apply standard methods to the increased volume of data. The second problem, which we intend to address here, is the absence of any research platform which bioinformaticians, computer scientists, and statisticians can use to develop novel methods that address both the volume and multidimensionality of the mounting tide of data. In our opinion, such a platform should be Open Source, be focused on visualization,  support rapid prototyping, have a large existing base of users, and have demonstrated suitability for development of new methods. We believe that the Open Source statistical software R in conjunction with the Bioconductor Project fills all of these requirements. Consequently we have developed a Bioconductor package that we call flowcore. The flowcore package is not intended to be a complete analysis package for FCM data, rather, we see it as providing a clear object model and a collection of standard tools that enable R as an informatics research platform for flow cytometry. One of the important issues that we have addressed in the flowcore package is that of using a standardized representation that will insure compatibility with existing technologies for data analysis and will support collaboration and interoperability of new methods as they are developed. In order to do this, we have followed the current standardized descriptions of FCM data analysis as being developed under NIH Grant xxxx [n]. We believe that researchers will find flowcore to be a solid foundation for future development of new methods to attack the many interesting open research questions in FCM data analysis.\\
\textbf{Methods} We propose a variety different data structures. We have implemented the classes and methods in the Bioconductor package flowcore. We illustrate their use with X case studies.\\
\textbf{Results} We hope that those proposed data structures will the base for the development of many tools for the analysis of high throughput flowcytometry.\\
\textbf{keywords} Flow cytometry, high throughtput, software, standard
\end{abstract}


\section{Introduction}
Traditionnally, flow cytometry has been a tube-based technique limited to small-scale laboratory and clinical studies. High throughput methods for flow cytometry have recently been developed for drug discovery and advanced research methods \cite{Gasparetto2004, Young2004}. As an example, the flow cytometry high content screening (FC-HCS) can process up to a thousand samples daily at a single workstation, and the results have been equivalent or superior to traditional manual multiparameter staining and analysis techniques. \\
The amount of information generated by high throughput technologies such as FC-HCS need to be transformed into executive summaries (which are brief enough) for creative studies by a human researcher \cite{Brazma2001}. Standardization is critical when developing new high throughput technologies and their associated information services \cite{Brazma2001, Chicurel2002, Boguski2003}. Standardization efforts have been made in clinical cell analysis by flow cytometry \cite{Keeney2004}, however data interpretation has not been standardized for even low throughput FCM. It is one of the most difficult and time consuming aspects of the entire analytical process as well as a primary source of variation in clinical tests, and investigators have traditionally relied on intuition rather than standardized statistical inference \cite{Bagwell2004,Braylan2004,Parks1997,Suni2003}. In the development of standards in high throughput FCM, few progress has been done in term of Open Source software. In this article we propose data structures to handle flow cytometry data through the main steps of prprocessing: compensation, transformation, filtering.\\



\section{Methodology}
\subsection{Reading data}
We first load the libraries and read the data into R as FCS object 
(rflowcyt data format). Note than this small example works for cytoFrame object. 
<<load library>>=
library("flowCore")
@ 
<<load data,echo=FALSE,results=hide>>=
fcs.loc <- system.file("extdata", package="flowCore")
file.location <- paste(fcs.loc, dir(fcs.loc), sep="/")
b08 <- read.FCS(file.location[1])
e07 <- read.FCS(file.location[2])
f06 <- read.FCS(file.location[3])
@
\begin{verbatim}
> fcs.loc <- system.file("extdata", package="flowCore")
> file.location <- paste(fcs.loc, dir(fcs.loc), sep="/")
> b08 = read.FCS(file.location[1])
> e07 = read.FCS(file.location[2])
> f06 = read.FCS(file.location[3])
\end{verbatim}

<<showB08,eval=FALSE,echo=FALSE>>=
show(b08)
@
 
We can plot the raw data for the FSC-H and SSC-H parameters.
<<plotRaw1,eval=TRUE, echo=FALSE,fig=TRUE,prefix=FALSE,include=FALSE>>=
plot(b08,plotParameters=c(1,2))
@
<<plotRaw2,eval=TRUE,echo=FALSE,fig=TRUE,prefix=FALSE,include=FALSE>>=
plot(b08,plotParameters=c(3,4))
@ 
\begin{verbatim}
> plot(b08,plotParameters=c(1,2))
> plot(b08,plotParameters=c(3,4))
> plot(e07,plotParameters=c(1,2))
> plot(f06,plotParameters=c(1,2))
\end{verbatim}

\begin{figure}
\centering
\subfigure{\includegraphics[width=40mm]{plotRaw1} A}
\subfigure{\includegraphics[width=40mm]{plotRaw2} B}
\caption{
  \label{fig:Fig01}{Example of smooth scatter plot.(A) FSC-H
    \textit{vs.} SSC-H (B) FL2-H \textit{vs.} FL3-H}} 
\end{figure}


\subsection{Transformation data}
While analyzing flow cytometry data, various parameter transformations are performed to provide user-friendly visualization and/or to perform statistical analyses and interpret the data. Following the standard 8 transformations are pre-defined: linear, quadratic, natural logarithm, logarithm (with a specified base), hyperlog, bi-exponential, logicle, and split-scale.

As example we performed two different tramsformations on "FSC-H" channel of sample b08: a linear tranformation and a log base 2 transformation. 

A linear transformation is like parameter= a*parameter +b
<<linearTransform,echo=FALSE,results=hide>>=
linear <- linearTransform(transformationId="linear-transformation",a=2, b=0)
Bb <- b08
colnames(Bb@exprs) <- paste("c",1:8,sep="")
data08Transform <- transform(Bb,c1=linear(c1))
@ 
\begin{verbatim}
>linear <- linearTransform(transformationId="linear-transformation",a=2, b=0)
>data08Transform <- transform(b08,FCS-H=linear(FCS-H))
\end{verbatim}

<<plotTRansfo,eval=FALSE, echo=FALSE,fig=TRUE,prefix=FALSE,include=FALSE>>=
plot(data08Transform,plotParameters=c(1,2))
@

A log transformation is of type: parameter=log(parameter,logbase) * r/d
<<logTransform,eval=FALSE,echo=FALSE,results=hide>>=
logTransform <- logTransformation(transformationId="Log-Transformation",
                r=1, d=1,logbase=2)
data08LogTransform <- transform(Bb,c1=logTransform(c1))
@ 
\begin{verbatim}
>logTransform <- logTransformation(transformationId="Log-Transformation", r=1, d=1,logbase=2)
>data08LogTransform <- transform(b08,FCS-H=logTransform(FCS-H))
\end{verbatim}
<<ResultTransfoLinear>>=
b08@exprs[1:5]
#Linear transformation
data08Transform@exprs[1:5]
##Log base 2 transformation
##data08LogTransform@exprs[1:5]
@
 
<<plotTRansfo,eval=FALSE, echo=FALSE,fig=TRUE,prefix=FALSE,include=FALSE>>=
##we should find a way to specified if an parameters has been transformed 
## either in the title or via the label of the axis 
plot(data08LogTransform,plotParameters=c("FSC-H","SSC-H"))
@

\subsection{Filtering data (gating)}
\subsubsection{Rectangular gate}
We will define rectangular gates and apply them to filter the bO8 data.
Figure \ref{fig:Fig02} presents the results of such filtering. 
The plot in Figure \ref{fig:Fig02}A shows the result of 
filtering out the data points that are below 200 in the FSC-H channel.
Figure \ref{fig:Fig02}B shows the result of 
filtering out the data points are between 200 
and 500  in the FSC-H channel.

<<define and apply rectangleGate1,eval=TRUE, echo=FALSE,results=hide>>=
min1 <- 200
max1 <- Inf
fil1 <- new("rectangleGate",filterId="nonDebris",
            parameters="FSC-H",min=min1,max=max1)
b08fil1 <- applyFilter(fil1,b08)
@ 
<<plotfiltered, eval=TRUE, echo=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08fil1,pch="*")
@ 
<<define and apply polygonGate2,eval=TRUE, echo=FALSE,results=hide>>=
min2 <- 200
max2 <- 500
centerFilter <- new("rectangleGate",filterId="center",
            parameters=c("FSC-H"), min=min2, max=max2)
b08centerFilter <- applyFilter(centerFilter,b08)
@ 
<<plotCenterfiltered, eval=TRUE, echo=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08centerFilter,pch="*")
@
 
\begin{figure}
\centering
\subfigure{\includegraphics[width=40mm]{plotfiltered} A}
\subfigure{\includegraphics[width=40mm]{plotCenterfiltered} B} 
\caption{
  \label{fig:Fig02}{Example of the effect of filtering with a rectangular gate.}} 
\end{figure}


\subsubsection{polygon gate}
%%We will define a rectangular gate and apply the filter it to the bO8 data.
<<define and apply rectangleGate,eval=TRUE,echo=FALSE>>=
sqrcut <- matrix(c(300,300,600,600,50,300,300,50),ncol=2,nrow=4)
sqrfilter <- new("polygonGate",filterId="nonDebris",
            parameters=c("FSC-H","SSC-H"),boundaries= sqrcut)
b08sqrfilter <- applyFilter(sqrfilter,b08)
@ 

<<plotRectanglefilter, eval=TRUE, echo=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08sqrfilter,pch="*")
@ 


<<define and apply polygonGate,eval=TRUE,echo=FALSE>>=
triangleCut <- matrix(c(300,400,600,300,400,300),ncol=2,nrow=3)
trianglefilter <- new("polygonGate",filterId="nonDebris",
            parameters=c("FSC-H","SSC-H"),boundaries= triangleCut)
b08Trgfilter <- applyFilter(trianglefilter,b08)
@ 

<<plotTrianglefilter, eval=TRUE, echo=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(x=b08,y=b08Trgfilter,filter=trianglefilter,colSubSet="red",pch="*")
@ 

\begin{figure}
\centering
\subfigure{\includegraphics[width=40mm]{plotRectanglefilter} A}
\subfigure{\includegraphics[width=40mm]{plotTrianglefilter} B} 
\caption{
  \label{fig:Fig03}{Example of the effect of filtering with a
    polygon gate.}} 
\end{figure}

\clearpage
\section{Case studies}
\subsection{BD}

<<rawdata1, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,plotParameters=c("FSC-H","SSC-H"),main="B08")
@
<<rawdata2, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>= 
plot(e07,plotParameters=c("FSC-H","SSC-H"),main="E07")
@
<<rawdata3, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(f06,plotParameters=c("FSC-H","SSC-H"),main="F06")
@ 
%%\begin{figure}
%%\centering
%%\subfigure{\includegraphics[width=40mm]{rawdata1}}
%%\subfigure{\includegraphics[width=40mm]{rawdata2}} 
%%\subfigure{\includegraphics[width=40mm]{rawdata3}} 
%%\caption{
%%  \label{fig:Fig04}{Example of the effect of filtering with a
%%    polygon gate.}} 
%%\end{figure}

The first gate is a range gate to filter out debris

<<SelectNonDebris,eval=TRUE,echo=FALSE,results=hide>>=
min1 <- c(200,0)
max1 <- c(800,800)
filter1 <- new("rectangleGate",filterId="Nondebris",parameters=c("FSC-H","SSC-H"),
  min=min1,max=max1)

b08.result1 <-  applyFilter(filter1,b08)
e07.result1 <- applyFilter(filter1,e07)
f06.result1 <- applyFilter(filter1,f06)

tab <- c("B08"=sum(b08.result1@subSet),"E07"=sum(e07.result1@subSet),"F06"=sum(f06.result1@subSet))
@ 
<<plotResFilter1, echo=FALSE, eval=FALSE,  fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08.result1,main="B08",pch="*")
@ 
<<plotResFilter2, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(e07,y=e07.result1,main="E07",pch="*")
@ 
<<plotResFilter3, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(f06,y=f06.result1,main="F06",pch="*")
@ 
%%\begin{figure}
%%\centering
%%\subfigure{\includegraphics[width=40mm]{plotResFilter1}}
%%\subfigure{\includegraphics[width=40mm]{plotResFilter2}} 
%%\subfigure{\includegraphics[width=40mm]{plotResFilter3}} 
%%\caption{
%%  \label{fig:Fig05}{Example of the effect of filtering with a
%%    polygon gate.}} 
%%\end{figure}

The second gate gets the live cells

<<FilterLiveCell,eval=TRUE,echo=FALSE,results=hide>>=
filter2 = new("norm2Filter",filterId="Live Cells",scale.factor=2,method="covMcd",parameters=c("FSC-H","SSC-H"))

b08.result2 = applyFilter(filter2,b08,parent=b08.result1)
e07.result2 = applyFilter(filter2,e07,parent=e07.result1)
f06.result2 = applyFilter(filter2,f06,parent=f06.result1)

tab <- rbind(tab,c(sum(b08.result2@subSet),sum(e07.result2@subSet),sum(f06.result2@subSet)))

@ 

<<plotLivingCell1, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08.result2,parent=b08.result1,xlim=c(0,1024),ylim=c(0,1024),main="B08",pch="*")
@ 
<<plotLivingCell2, echo=FALSE, eval=FALSE,  fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(e07,y=e07.result2,parent=e07.result1,xlim=c(0,1024),ylim=c(0,1024),main="E07",pch="*")
@ 
<<plotLivingCell3, echo=FALSE, eval=FALSE, fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(f06,y=f06.result2,parent=f06.result1, xlim=c(0,1024),ylim=c(0,1024),main="F06",pch="*")
@ 
%%\begin{figure}
%%\centering
%%\subfigure{\includegraphics[width=40mm]{plotLivingCell1}}
%%\subfigure{\includegraphics[width=40mm]{plotLivingCell2}} 
%%\subfigure{\includegraphics[width=40mm]{plotLivingCell3}} 
%%\caption{
%%  \label{fig:Fig06}{Example of the effect of filtering with a
%%    polygon gate.}} 
%%\end{figure}

The third-fifth gates get the positive cells for the marker in FL1-H. 
This is a really interesting example because it illustrates that there
are two subpopulations. Naturally we would like to automatically find them
In this case we want to now what percent the positive population in FL1-H 
is of the total population.

<<FL1-H, echo=FALSE, eval=FALSE,fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,parent=b08.result2,plotParameters=c("FSC-H","FL1-H"),ylim=c(0,1024),xlim=c(0,1024))
@ 
%%\begin{figure}
%%\centering
%%\includegraphics{FL1-H}
%%\end{figure}

<<FL1Filter,eval=TRUE,echo=FALSE,results=hide>>=
filter3 <- new("rectangleGate",filterId="FL1-H+",parameters="FL1-H",min=400,max=Inf)
b08.result3 <- applyFilter(filter3,b08,b08.result2)

filter4 <-new("norm2Filter",filterId="FL1-H+",scale.factor=2,method="covMcd",parameters=c("FSC-H","FL1-H"))
b08.result4 <- applyFilter(filter4,b08,b08.result2)

##b08.result5 <- applyFilter(filter4,b08,b08.result2@subSet-b08.result4@subSet)

##ans <- c(sum(b08.result3@subSet)/sum(b08.result2@subSet),
##sum(b08.result4@subSet)/(sum(b08.result4@subSet)+sum(b08.result5@subSet)))
@

<<FL1Filtered1, echo=FALSE, eval=FALSE,  fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08.result3,parent=b08.result2,plotParameters=c("FSC-H","FL1-H"),
          xlim=c(0,1024),ylim=c(0,1024),pch="*")
@ 
<<FL1Filtered2, echo=FALSE, eval=FALSE,fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08.result4,parent=b08.result2,plotParameters=c("FSC-H","FL1-H"),
          xlim=c(0,1024),ylim=c(0,1024),pch="*")
@ 
<<FL1Filtered3, echo=FALSE, eval=FALSE,fig=TRUE, prefix=FALSE, include=FALSE>>=
plot(b08,y=b08.result5,parent=b08.result2,plotParameters=c("FSC-H","FL1-H"),
          xlim=c(0,1024),ylim=c(0,1024),pch="*")
@

%%\begin{figure}
%%\centering
%%\subfigure{\includegraphics[width=40mm]{FL1Filtered1}}
%%\subfigure{\includegraphics[width=40mm]{FL1Filtered2}} 
%%\subfigure{\includegraphics[width=40mm]{FL1Filtered3}} 
%%\caption{
%%  \label{fig:Fig07}{Example of the effect of filtering with a
%%    polygon gate.}} 
%%\end{figure}


\clearpage
\small{
<<sessionInfo>>=
sessionInfo()
@ 
}
\end{document}
